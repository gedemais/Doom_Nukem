/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raster_triangles.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gedemais <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/02 02:08:49 by gedemais          #+#    #+#             */
/*   Updated: 2020/02/02 07:17:52 by gedemais         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "main.h"
/*
static void	draw_triangle(t_mlx *mlx, t_point a, t_point b, t_point c)
{
	draw_line(mlx, a, b, 0xffffff);
	draw_line(mlx, a, c, 0xffffff);
	draw_line(mlx, b, c, 0xffffff);
}
*/

void		*rasthreader(void *param)
{
	t_rasthread	*thr;
	t_triangle	*t;
	t_env		*env;
	int			i;

	thr = (t_rasthread*)param;
	env = thr->env;
	i = thr->start;
	while (thr->index < thr->end)
	{
		t = (t_triangle*)dyacc(&env->cam.to_raster, thr->index);
		fill_triangle_unit((t_env*)thr->env, *t, shade_color(t->color, t->illum));
//		draw_triangle(&env->mlx, (t_point){t->points[0].x, t->points[0].y},
//			(t_point){t->points[1].x, t->points[1].y}, (t_point){t->points[2].x, t->points[2].y});
		thr->index++;
	}
	thr->done = true;
	if (thr->mono)
		return (NULL);
	else
		pthread_exit(NULL);
}

static int	relaunch_thread(t_rasthread threads[NB_THREADS], unsigned int i)
{
	unsigned int	j;
	unsigned int	t;
	unsigned int	work;
	unsigned int	max_work;

	j = 0;
	max_work = 0;
	while (j < NB_THREADS)
	{
		work = threads[j].end - threads[j].index;
		if (i != j && work > max_work)
		{
			max_work = work;
			t = j;
		}
		j++;
	}
	threads[i].start = threads[t].index + (max_work / 2); // Placing new's start
	threads[i].index = threads[i].start; // Placing new's start
	threads[i].end = threads[t].end; // Placing new's end
	threads[t].end = threads[i].start; // Copying on weak's end
	threads[i].done = false;
	threads[t].done = false;
	if (pthread_create(&threads[i].thread, NULL, rasthreader, &threads[i]))
		return (-1);
	return (threads[i].start - threads[i].end);
}

static void	manage_threads(t_rasthread threads[NB_THREADS], t_dynarray *arr)
{
	unsigned int	i;
	int				waste;
	int				amount;

	amount = INT_MAX;
	waste = (arr->nb_cells / NB_THREADS);
	while (amount > waste)
	{
		i = 0;
		while (i < NB_THREADS)
		{
			if (threads[i].done)
			{
				amount = relaunch_thread(threads, i);
				break ;
			}
			i++;
		}
	}
}

static int	launch_thread(t_env *env, t_rasthread *thread, int work_size, int r)
{
	static int	rest = 0;

	if (!rest)
		rest = r;
	thread->env = env;
	thread->tris = &env->cam.to_raster;
	thread->start = i * (work_size / NB_THREADS);
	thread->index = threads[i].start;
	thread->end = threads[i].start + (work_size / NB_THREADS) + r;
	thread->done = false;
	thread->mono = false;
	if (pthread_create(&thread->thread, NULL, rasthreader, thread))
				return (-1);
	return (0);
}

static int	switch_threads(t_env *env, t_rasthread threads[NB_THREADS],
														int work_size, bool w)
{
	int		i;
	int		rest;

	i = 0;
	rest = work_size % NB_THREADS;
	while (i < NB_THREADS && i < work_size)
	{
		if (w)
		{
			if (pthread_join(threads[i].thread, NULL))
				return (-1);
		}
		else
		{
			threads[i].index = i;
			if (launch_thread(env, &threads[i], work_size, rest--))
				return (-1);
		}
		i++;
	}
	return (0);
}

int			raster_triangles(void *e, t_dynarray *arr)
{
	t_rasthread	threads[NB_THREADS];
	t_env		*env;
	int			i;

	i = -1;
	env = e;
	clip_mesh_triangles(arr, &env->cam.to_raster, env->cam.clip_arrs);

	if (env->cam.to_raster.nb_cells < NB_THREADS)
		monothread_raster(env);
	else
	{
		switch_threads(env, threads, env->cam.to_raster.nb_cells, false);
		manage_threads(threads, arr);
		switch_threads(env, threads, env->cam.to_raster.nb_cells, true);
	}

	clear_dynarray(&env->cam.to_raster);
	return (0);
}
